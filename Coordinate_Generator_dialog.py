# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Coordinate_GeneratorDialog
                                 A QGIS plugin
 좌표 생성기(네이버api)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-09-03
        git sha              : $Format:%H$
        copyright            : (C) 2025 by LCY부동산중개법인
        email                : lcy5002@naver.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import QMessageBox
import re
import requests
from qgis.core import QgsProject

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Coordinate_Generator_dialog_base.ui'))


class Coordinate_GeneratorDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(Coordinate_GeneratorDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.field_combos = []  # 동적으로 생성되는 콤보박스 리스트
        self.comboBox.currentIndexChanged.connect(self.onCountChanged)
        self.LayerName.currentIndexChanged.connect(self.onLayerChanged)

        # widget에 레이아웃이 없으면 QVBoxLayout을 설정
        if self.widget.layout() is None:
            layout = QtWidgets.QVBoxLayout(self.widget)
            self.widget.setLayout(layout)

        # 다이얼로그가 처음 로딩될 때 1개의 드롭박스가 생성되도록 함
        self.onCountChanged(self.comboBox.currentIndex())


        # <실행버튼눌렀을 때, 취소버튼 눌렀을 때 연결>
        self.pbRun.clicked.connect(self.onRunClicked)
        self.pbCancel.clicked.connect(self.onCancelClicked)
        # </실행버튼눌렀을 때, 취소버튼 눌렀을 때 연결>
    


    def get_current_layer_field_names(self):
        layer_name = self.LayerName.currentText()
        layers = QgsProject.instance().mapLayersByName(layer_name)
        if layers:
            layer = layers[0]
            return [field.name() for field in layer.fields()]
        return []

    def onLayerChanged(self, idx):
        # 레이어가 바뀌면 필드명 갱신 및 콤보박스 아이템 갱신
        field_names = self.get_current_layer_field_names()
        for combo in self.field_combos:
            combo.clear()
            combo.addItems(field_names)

    def onCountChanged(self, idx):
        # 기존 콤보박스 제거
        for combo in self.field_combos:
            self.widget.layout().removeWidget(combo)
            combo.deleteLater()
        self.field_combos = []

        # 선택된 개수만큼 콤보박스 생성
        count = int(self.comboBox.currentText())
        field_names = self.get_current_layer_field_names()
        for i in range(count):
            combo = QtWidgets.QComboBox(self)
            combo.addItems(field_names)
            self.widget.layout().addWidget(combo)
            self.field_combos.append(combo)


    @staticmethod
    def geocode_address(address, client_id, client_secret):
        url = "https://maps.apigw.ntruss.com/map-geocode/v2/geocode"
        headers = {
            "x-ncp-apigw-api-key-id": client_id,
            "x-ncp-apigw-api-key": client_secret,
            "Accept": "application/json"
        }
        params = {"query": address}
        try:
            response = requests.get(url, headers=headers, params=params)
            if response.status_code == 200:
                data = response.json()
                if data.get("addresses"):
                    addr = data["addresses"][0]
                    return {
                        "roadAddress": addr.get("roadAddress", ""),
                        "jibunAddress": addr.get("jibunAddress", ""),
                        "x": float(addr["x"]) if "x" in addr else None,
                        "y": float(addr["y"]) if "y" in addr else None
                    }
            return None
        except Exception as e:
            print(f"지오코딩 오류: {e}")
            return None


    def onRunClicked(self):
        client_id = self.client_id.text()
        client_id = re.sub(r"\s+", "", client_id)
        
        client_secret = self.client_secret.text()
        client_secret = re.sub(r"\s+", "", client_secret)

        if client_id == "" or client_secret == "":
            QtWidgets.QMessageBox.warning(self, "경고", "client_id, client_secret 모두 입력하세요.")
            return
        
        LayerName = self.LayerName.currentText()
        # 동적으로 생성된 콤보박스에서 선택된 필드명 리스트
        selected_field_names = [combo.currentText() for combo in self.field_combos]

        layer = QgsProject.instance().mapLayersByName(f'{LayerName}')[0]
                
        from qgis.core import QgsVectorLayer, QgsField, QgsFeature, QgsGeometry, QgsPointXY
        from PyQt5.QtCore import QVariant   

        results = []

        # 1. 기존 레이어의 필드 복사
        fields = layer.fields()
        mem_layer = QgsVectorLayer("Point?crs=EPSG:4326", "Geocoded Results", "memory")
        pr = mem_layer.dataProvider()
        pr.addAttributes(fields)
        pr.addAttributes([
            QgsField("x", QVariant.Double),
            QgsField("y", QVariant.Double)
        ])
        mem_layer.updateFields()

        # 2. 피처 복사 및 좌표 변환 (병렬 처리)
        from concurrent.futures import ThreadPoolExecutor, as_completed
        features = list(layer.getFeatures())
        # 선택된 필드명들의 값을 결합해서 주소 리스트 생성
        addresses = [" ".join([str(feature[field_name]) for field_name in selected_field_names if field_name]) for feature in features]

        # 주소 중복 제거 및 매핑 정보 생성
        address_to_indices = {}
        unique_addresses = []
        for idx, addr in enumerate(addresses):
            if addr not in address_to_indices:
                address_to_indices[addr] = []
                unique_addresses.append(addr)
            address_to_indices[addr].append(idx)

        # 중복 제거 후 실제 지오코딩 요청 개수 확인
        unique_count = len(unique_addresses)
        if unique_count >= 1000:
            reply = QMessageBox.question(self, "경고", f"중복 제거 후 실제 지오코딩 요청이 {unique_count}건 발생합니다. 1,000건 이상은 시간이 오래 걸릴 수 있습니다. 계속 진행하시겠습니까?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply != QMessageBox.Yes:
                return
        # 프로그래스바 설정
        startsNum = len(addresses)
        self.pbPercent.setMaximum(startsNum)
        self.pbPercent.setValue(0)
        
        def geocode_wrapper(address):
            return self.geocode_address(address, client_id, client_secret)
        
        geocoded_unique_results = [None] * len(unique_addresses)
        max_workers = 100  # 동시에 요청할 쓰레드 수 (API 쿼터에 맞게 조절)
        finished_count = 0
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_idx = {executor.submit(geocode_wrapper, addr): idx for idx, addr in enumerate(unique_addresses)}
            for future in as_completed(future_to_idx):
                idx = future_to_idx[future]
                try:
                    geo = future.result()
                except Exception as exc:
                    geo = None
                geocoded_unique_results[idx] = geo
                finished_count += len(address_to_indices[unique_addresses[idx]])
                self.pbPercent.setValue(finished_count)

        # feature 순서에 맞게 결과 매핑
        geocoded_results = [None] * startsNum
        for unique_idx, addr in enumerate(unique_addresses):
            for idx in address_to_indices[addr]:
                geocoded_results[idx] = geocoded_unique_results[unique_idx]
        
        for idx, feature in enumerate(features):
            attrs = feature.attributes()
            address = addresses[idx]
            geo = geocoded_results[idx]
            if geo and geo['x'] and geo['y']:
                f = QgsFeature(mem_layer.fields())
                f.setAttributes(attrs + [geo['x'], geo['y']])
                f.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(geo['x'], geo['y'])))
                pr.addFeature(f)
                results.append(f"{address}: x={geo['x']}, y={geo['y']}")
            else:
                f = QgsFeature(mem_layer.fields())
                f.setAttributes(attrs + [None, None])
                pr.addFeature(f)
                results.append(f"{address}: 지오코딩 실패")

        mem_layer.updateExtents()

        numeric_fields = ["전용면적(㎡)", "계약년월", "계약일"]
        money_field = "거래금액(만원)"
        money_field_new = "거래금액(원)"
        mem_fields = mem_layer.fields()

        exist_numeric_fields = [f for f in numeric_fields if mem_fields.indexOf(f) != -1]
        has_money_field = mem_fields.indexOf(money_field) != -1

        # 4개 중 하나라도 있으면 변환, 아니면 원본만 추가
        if exist_numeric_fields or has_money_field:
            converted_layer = QgsVectorLayer("Point?crs=EPSG:4326", "Converted Layer", "memory")
            converted_pr = converted_layer.dataProvider()

            new_fields = []
            for field in mem_fields:
                if field.name() == money_field:
                    new_fields.append(QgsField(money_field_new, QVariant.Double))
                elif field.name() in exist_numeric_fields:
                    if field.name() == "전용면적(㎡)":
                        new_fields.append(QgsField(field.name(), QVariant.Double))
                    else:
                        new_fields.append(QgsField(field.name(), QVariant.Int))
                else:
                    new_fields.append(field)
            converted_pr.addAttributes(new_fields)
            converted_layer.updateFields()

            for feature in mem_layer.getFeatures():
                attrs = []
                for i, field in enumerate(mem_fields):
                    val = feature[i]
                    field_name = field.name()
                    if field_name == money_field:
                        try:
                            money_str = str(val).replace(",", "")
                            money_num = float(money_str) * 10000
                        except:
                            money_num = None
                        attrs.append(money_num)
                    elif field_name in exist_numeric_fields:
                        try:
                            if field_name == "전용면적(㎡)":
                                attrs.append(float(val))
                            else:
                                attrs.append(int(val))
                        except:
                            attrs.append(None)
                    elif field_name != money_field:
                        attrs.append(val)
                new_feature = QgsFeature(converted_layer.fields())
                new_feature.setAttributes(attrs)
                new_feature.setGeometry(feature.geometry())
                converted_pr.addFeature(new_feature)

            converted_layer.updateExtents()
            QgsProject.instance().addMapLayer(converted_layer)
        else:
            QgsProject.instance().addMapLayer(mem_layer)





    # <취소버튼 눌렀을 때 연결되는 함수>
    def onCancelClicked(self):
        self.close()
    # </취소버튼 눌렀을 때 연결되는 함수>
